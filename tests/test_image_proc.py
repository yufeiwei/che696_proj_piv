#!/usr/bin/env python3
"""
Unit and regression test for the che696_proj_yufei package.
"""

# Import package, test suite, and other packages as needed
import errno
import os
import sys
import unittest
from contextlib import contextmanager
from io import StringIO
import numpy as np
import logging
from che696_proj_yufei.image_proc import main, piv_analysis, x_corr, divid_image

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
DISABLE_REMOVE = logger.isEnabledFor(logging.DEBUG) # True or False

CURRENT_DIR = os.path.dirname(__file__)
MAIN_DIR = os.path.join(CURRENT_DIR, '..')
TEST_DATA_DIR = os.path.join(CURRENT_DIR, 'data_proc')
PROJ_DIR = os.path.join(MAIN_DIR, 'che696_proj_yufei')
DATA_DIR = os.path.join(PROJ_DIR, 'data')
SAMPLE_DATA_FILE_LOC = [os.path.join(DATA_DIR, 'sample_im1.bmp'), os.path.join(DATA_DIR, 'sample_im2.bmp')]

# Assumes running tests from the main directory
DEF_CSV_OUT = os.path.join(MAIN_DIR, 'test_piv_results.csv')
DEF_PNG_OUT = os.path.join(MAIN_DIR, 'test_piv_plot.png')

def silent_remove(filename, disable=False):
    """
    Removes the target file name, catching and ignoring errors that indicate that the
    file does not exist.

    @param filename: The file to remove.
    @param disable: boolean to flag if want to disable removal
    """
    if not disable:
        try:
            os.remove(filename)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

class TestMain(unittest.TestCase):
    # These tests make sure that the program can run properly from main
    def testSampleData(self):
        # Checks that runs with defaults and that files are created
        test_input = ["-m", SAMPLE_DATA_FILE_LOC[0], SAMPLE_DATA_FILE_LOC[1]]
        try:
            if logger.isEnabledFor(logging.DEBUG):
                main(test_input)
            # checks that the expected message is sent to standard out
            with capture_stdout(main, test_input) as output:
                self.assertTrue("piv_results_sample_im1_sample_im2.csv" in output)

            self.assertTrue(os.path.isfile("piv_results_sample_im1_sample_im2.csv"))
            self.assertTrue(os.path.isfile("piv_results_sample_im1_sample_im2.png"))
        finally:
            silent_remove(DEF_CSV_OUT, disable=DISABLE_REMOVE)
            silent_remove(DEF_PNG_OUT, disable=DISABLE_REMOVE)

class TestMainFailWell(unittest.TestCase):
    def testMissingFile(self):
        # Make sure to capture errors due to nonexistent files
        test_input = ["-m", "ghost1.txt", "ghost2.txt"]
        if logger.isEnabledFor(logging.DEBUG):
            main(test_input)
        with capture_stderr(main, test_input) as output:
            self.assertTrue("ghost" in output)
    def testInvalidImage(self):
        # Make sure to capture errors due to invalid image files
        input_image_1 = os.path.join(TEST_DATA_DIR, "invalid_im1.png")
        input_image_2 = os.path.join(TEST_DATA_DIR, "invalid_im2.png")
        test_input = ["-m", input_image_1, input_image_2]
        if logger.isEnabledFor(logging.DEBUG):
            main(test_input)
        with capture_stderr(main, test_input) as output:
            self.assertTrue("invalid image" in output)
    def testInvalidImagePair(self):
        # Make sure to capture errors due to invalid image files
        input_image_1 = os.path.join(TEST_DATA_DIR, "sample2_im1.bmp")
        input_image_2 = os.path.join(TEST_DATA_DIR, "sample2_im2_crop.jpg")
        test_input = ["-m", input_image_1, input_image_2]
        if logger.isEnabledFor(logging.DEBUG):
            main(test_input)
        with capture_stderr(main, test_input) as output:
            self.assertTrue("different sizes" in output)

class TestPivAnalysis(unittest.TestCase):
    def testSampleData(self):
        # Tests that the PIV results generated by the piv_analysis function matches saved expected results
        sample_im1_path = SAMPLE_DATA_FILE_LOC[0]
        sample_im2_path = SAMPLE_DATA_FILE_LOC[1]
        division_pixel = 5
        analysis_results = piv_analysis(sample_im1_path, sample_im2_path, division_pixel)
        expected_results = np.loadtxt(fname=os.path.join(TEST_DATA_DIR, "sample_results_ndiv5.csv"), delimiter=',')
        self.assertTrue(np.allclose(expected_results, analysis_results))

    def testSampleData2(self):
        # A second check, with slightly different values, of the piv_analysis function
        sample_im1_path = SAMPLE_DATA_FILE_LOC[0]
        sample_im2_path = SAMPLE_DATA_FILE_LOC[1]
        division_pixel = 20
        analysis_results = piv_analysis(sample_im1_path, sample_im2_path, division_pixel)
        expected_results = np.loadtxt(fname=os.path.join(TEST_DATA_DIR, "sample_results_ndiv20.csv"), delimiter=',')
        self.assertTrue(np.allclose(expected_results, analysis_results))

class TestXCorr(unittest.TestCase):
    def testSampleData(self):
        # Tests that the x_corr function works correctly
        x1 = np.linspace(0,20,500)
        y1 = [np.sin(x1)]
        y2 = [np.sin(x1 + 1)]
        analysis_results = x_corr(y1, y2)[0]
        self.assertEqual(analysis_results, -23.)

class TestDividImage(unittest.TestCase):
    def testSampleData(self):
        # Tests that the divid_image function works correctly
        np.random.seed(1)
        a = np.random.rand(10,5)
        b = np.random.rand(10,5)
        my_input = np.concatenate((a,b))
        out_a, out_b = divid_image(my_input, 5)
        self.assertEqual(out_b, [2.5, 7.5, 12.5, 17.0])


# Utility functions
# From http://schinckel.net/2013/04/15/capture-and-test-sys.stdout-sys.stderr-in-unittest.testcase/
@contextmanager
def capture_stdout(command, *args, **kwargs):
    # pycharm doesn't know six very well, so ignore the false warning
    # noinspection PyCallingNonCallable
    out, sys.stdout = sys.stdout, StringIO()
    command(*args, **kwargs)
    sys.stdout.seek(0)
    yield sys.stdout.read()
    sys.stdout = out

@contextmanager
def capture_stderr(command, *args, **kwargs):
    # pycharm doesn't know six very well, so ignore the false warning
    # noinspection PyCallingNonCallable
    err, sys.stderr = sys.stderr, StringIO()
    command(*args, **kwargs)
    sys.stderr.seek(0)
    yield sys.stderr.read()
    sys.stderr = err